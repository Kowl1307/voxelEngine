using System.Collections.Generic;using System.Linq;using Unity.Mathematics.Geometry;using UnityEngine;using Voxel_Engine.WorldGen.Biomes;using Math = System.Math;namespace Voxel_Engine{    public static class WorldDataHelper    {        public static Vector3Int GetChunkPositionFromVoxelCoords(World world, Vector3Int voxelCoords)        {            return new Vector3Int            {                x = Mathf.FloorToInt(voxelCoords.x / (float)world.WorldData.ChunkSizeInVoxel) * world.WorldData.ChunkSizeInVoxel,                y = Mathf.FloorToInt(voxelCoords.y / (float)world.WorldData.ChunkHeightInVoxel) * world.WorldData.ChunkHeightInVoxel,                z = Mathf.FloorToInt(voxelCoords.z / (float)world.WorldData.ChunkSizeInVoxel) * world.WorldData.ChunkSizeInVoxel            };        }        public static Vector3Int GetChunkWorldPositionFromWorldCoords(World world, int worldX, int worldY, int worldZ) => GetChunkWorldPositionFromWorldCoords(world, new Vector3Int(worldX, worldY, worldZ));                public static Vector3Int GetChunkWorldPositionFromWorldCoords(World world, Vector3Int worldCoords)        {            return new Vector3Int            {                x = Mathf.RoundToInt(worldCoords.x / (float)world.chunkSizeInWorld) * world.chunkSizeInWorld,                y = Mathf.RoundToInt(worldCoords.y / (float)world.chunkHeightInWorld) * world.chunkHeightInWorld,                z = Mathf.RoundToInt(worldCoords.z / (float)world.chunkSizeInWorld) * world.chunkSizeInWorld            };        }        public static Vector3Int GetVoxelPositionFromWorldPosition(World world, Vector3 worldCoords)        {            return new Vector3Int            {                x = Mathf.RoundToInt(worldCoords.x / (float)world.chunkSizeInWorld * world.WorldData.ChunkSizeInVoxel),                y = Mathf.RoundToInt(worldCoords.y / (float)world.chunkHeightInWorld * world.WorldData.ChunkHeightInVoxel),                z = Mathf.RoundToInt(worldCoords.z / (float)world.chunkSizeInWorld * world.WorldData.ChunkSizeInVoxel)            };        }                public static Vector3 GetWorldPositionFromVoxelPosition(World world, Vector3Int voxelCoords)        {            return new Vector3            {                x = voxelCoords.x / (float)world.WorldData.ChunkSizeInVoxel * world.chunkSizeInWorld,                y = voxelCoords.y / (float)world.WorldData.ChunkHeightInVoxel * world.chunkHeightInWorld,                z = voxelCoords.z / (float)world.WorldData.ChunkSizeInVoxel * world.chunkSizeInWorld            };        }                public static Vector3Int GetChunkWorldPositionFromVoxelCoords(World world, Vector3Int voxelCoords) => GetChunkWorldPositionFromVoxelCoords(world, voxelCoords.x, voxelCoords.y, voxelCoords.z);                public static Vector3Int GetChunkWorldPositionFromVoxelCoords(World world, int voxelPositionX, int voxelPositionY, int voxlePositionZ)        {            var pos = new Vector3Int            {                x = Mathf.FloorToInt(voxelPositionX / (float)world.WorldData.ChunkSizeInVoxel) * world.chunkSizeInWorld,                y = Mathf.FloorToInt(voxelPositionY / (float)world.WorldData.ChunkHeightInVoxel) * world.chunkHeightInWorld,                z = Mathf.FloorToInt(voxlePositionZ / (float)world.WorldData.ChunkSizeInVoxel) * world.chunkSizeInWorld            };            return pos;        }                public static List<Vector3Int> GetChunkPositionsAroundPlayer(World world, Vector3Int playerPosition)        {            //TODO This whole thing is working with ints, even though the world coordinates are not ints...            // This needs to be changed to calculate the voxel positions instead.            //We calculate the chunk world position to avoid potential rounding errors in calculation            var playerWorldPos = GetChunkWorldPositionFromWorldCoords(world, playerPosition);            var startX = playerWorldPos.x - (world.ChunkDrawingRange) * world.chunkSizeInWorld;            var startZ = playerWorldPos.z - (world.ChunkDrawingRange) * world.chunkSizeInWorld;            var endX = playerWorldPos.x + (world.ChunkDrawingRange) * world.chunkSizeInWorld;             var endZ = playerWorldPos.z + (world.ChunkDrawingRange) * world.chunkSizeInWorld;            return GetPositionsAroundPlayer(world, startX, startZ, endX, endZ, playerPosition);        }        public static List<Vector3Int> GetDataPositionsAroundPlayer(World world, Vector3Int playerPosition)        {            //We calculate the chunk world position to avoid potential rounding errors in calculation            var playerWorldPos = GetChunkWorldPositionFromWorldCoords(world, playerPosition);            var startX = playerWorldPos.x - (world.ChunkDrawingRange + 1) * world.chunkSizeInWorld;            var startZ = playerWorldPos.z - (world.ChunkDrawingRange + 1) * world.chunkSizeInWorld;            var endX = playerWorldPos.x + (world.ChunkDrawingRange + 1) * world.chunkSizeInWorld;            var endZ = playerWorldPos.z + (world.ChunkDrawingRange + 1) * world.chunkSizeInWorld;            return GetPositionsAroundPlayer(world, startX, startZ, endX, endZ, playerPosition);        }        /// <summary>        /// Get Chunk positions around the player        /// </summary>        /// <param name="world"></param>        /// <param name="startX"></param>        /// <param name="startZ"></param>        /// <param name="endX"></param>        /// <param name="endZ"></param>        /// <param name="playerPosition">In world space</param>        /// <returns></returns>        private static List<Vector3Int> GetPositionsAroundPlayer(World world, int startX, int startZ, int endX,            int endZ, Vector3Int playerPosition)        {            var positions = new List<Vector3Int>();            for (var x = startX; x <= endX; x += world.chunkSizeInWorld)            {                for (var z = startZ; z <= endZ; z += world.chunkSizeInWorld)                {                    //var chunkPos = GetChunkPositionFromVoxelCoords(world, new Vector3Int(x, 0, z));                    var chunkPos = GetChunkWorldPositionFromWorldCoords(world, new Vector3Int(x,0,z));                    positions.Add(chunkPos);                    //positions.Add(Vector3Int.FloorToInt(Vector3.Scale(chunkPos, world.voxelScaling)));                                        //Also add chunks below the current one, for digging down scenarios                    if(x < playerPosition.x - world.chunkSizeInWorld                        || x > playerPosition.x + world.chunkSizeInWorld                        || z < playerPosition.z - world.chunkSizeInWorld                        || z > playerPosition.z + world.chunkSizeInWorld) continue;                                        for (var y = -world.chunkHeightInWorld; y >= playerPosition.y - world.chunkHeightInWorld * 2; y -= world.chunkHeightInWorld)                    {                        if (y == 0) continue;                        chunkPos = GetChunkWorldPositionFromWorldCoords(world, new Vector3Int(x, y, z));                        //chunkPos = GetChunkPositionFromVoxelCoords(world, new Vector3Int(x, y, z));                        positions.Add(chunkPos);                        //positions.Add(Vector3Int.FloorToInt(Vector3.Scale(chunkPos, world.voxelScaling)));                    }                }            }            return positions;        }        public static List<Vector3Int> SelectPositionsToCreate(WorldData worldData, List<Vector3Int> allChunkPositionsNeeded, Vector3Int playerPosition)        {            return allChunkPositionsNeeded                .Where(pos => worldData.ChunkDictionary.ContainsKey(pos) == false)                .OrderBy(pos => Vector3.Distance(playerPosition, pos))                .ToList();        }        public static List<Vector3Int> SelectDataPositionsToCreate(WorldData worldData, List<Vector3Int> allChunkDataPositionsNeeded, Vector3Int playerPosition)        {            return allChunkDataPositionsNeeded                .Where(pos => worldData.ChunkDataDictionary.ContainsKey(pos) == false)                .OrderBy(pos => Vector3.Distance(playerPosition, pos))                .ToList();        }        public static List<Vector3Int> GetUnneededChunks(WorldData worldData, List<Vector3Int> allChunkPositionsNeeded)        {            return worldData.ChunkDictionary.Keys                .Where(pos => allChunkPositionsNeeded.Contains(pos) == false)                .ToList();        }        public static List<Vector3Int> GetUnneededData(WorldData worldData, List<Vector3Int> allChunkDataPositionsNeeded)        {            return worldData.ChunkDataDictionary.Keys                .Where(pos => allChunkDataPositionsNeeded.Contains(pos) == false                               && worldData.ChunkDataDictionary[pos].IsDirty() == false                              )                .ToList();        }        public static void RemoveChunk(World world, Vector3Int pos)        {            if (!world.WorldData.ChunkDictionary.TryGetValue(pos, out var chunk)) return;            world.WorldRenderer.RemoveChunk(chunk);            world.WorldData.ChunkDictionary.TryRemove(pos, out _);        }        public static void RemoveChunkData(World world, Vector3Int pos)        {            world.WorldData.ChunkDataDictionary.TryRemove(pos, out _);        }        public static void SetVoxel(World world, Vector3Int voxelCoords, VoxelType voxelType)        {            var chunkData = GetChunkDataFromVoxelCoords(world, voxelCoords);            if (chunkData == null) return;            var localPos = Chunk.GetChunkCoordinateOfVoxelPosition(chunkData, voxelCoords);            Chunk.SetVoxel(chunkData, localPos, voxelType);        }        public static ChunkData GetChunkDataFromVoxelCoords(World world, Vector3Int voxelCoords)         {            var chunkPos = GetChunkWorldPositionFromVoxelCoords(world, voxelCoords);            world.WorldData.ChunkDataDictionary.TryGetValue(chunkPos, out var containerChunk);            return containerChunk;        }        public static ChunkRenderer GetChunk(World worldReference, Vector3Int worldPosition)        {            return worldReference.WorldData.ChunkDictionary.GetValueOrDefault(worldPosition);        }        public static VoxelType GetVoxelTypeAt(World world, Vector3Int voxelPosition)        {            var chunkData = GetChunkDataFromVoxelCoords(world, voxelPosition);            return chunkData == null ?                world.terrainGenerator.ProcessVoxelAt(world, voxelPosition) :                Chunk.GetVoxelTypeAt(chunkData, Chunk.GetChunkCoordinateOfVoxelPosition(chunkData, voxelPosition));        }        public static int GetSurfaceHeightAt(World world, Vector3Int voxelPosition)        {            var chunkData = GetChunkDataFromVoxelCoords(world, voxelPosition);            return chunkData == null ?                 world.terrainGenerator.GetSurfaceHeightAt(world, voxelPosition) :                Chunk.GetSurfaceHeight(chunkData, voxelPosition.XZ());        }        public static List<Vector3Int> GetAdjacentChunkPositionsInVoxel(World world, Vector3Int chunkPositionInVoxel)        {            var chunkSize = world.WorldData.ChunkSizeInVoxel;            List<Vector3Int> adjacentChunkPositions = new()            {                // "Below" -z                chunkPositionInVoxel + new Vector3Int(-chunkSize, 0, -chunkSize),                chunkPositionInVoxel + new Vector3Int(0, 0, -chunkSize),                chunkPositionInVoxel + new Vector3Int(chunkSize, 0, -chunkSize),                                //Center line (including the given position                chunkPositionInVoxel + new Vector3Int(-chunkSize, 0, 0),                chunkPositionInVoxel + new Vector3Int(chunkSize, 0, 0),                                // "Above" +z                chunkPositionInVoxel + new Vector3Int(-chunkSize, 0, chunkSize),                chunkPositionInVoxel + new Vector3Int(0, 0, chunkSize),                chunkPositionInVoxel + new Vector3Int(chunkSize, 0, chunkSize),            };            return adjacentChunkPositions;        }        public static BiomeType GetBiomeAt(World world, Vector3Int voxelPosition)        {            return world.terrainGenerator.GetBiomeAt(world, voxelPosition);        }    }}