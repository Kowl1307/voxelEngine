using System.Collections.Generic;using Kowl.Utils;using Unity.Mathematics.Geometry;using UnityEngine;using Voxel_Engine.WorldGen.Biomes;namespace Voxel_Engine{    public static class WorldDataHelper    {        public static Vector3Int GetChunkPositionFromVoxelCoords(WorldData worldData, Vector3Int voxelCoords)        {            return new Vector3Int            {                x = Mathf.FloorToInt(voxelCoords.x / (float)worldData.ChunkSizeInVoxel) * worldData.ChunkSizeInVoxel,                y = Mathf.FloorToInt(voxelCoords.y / (float)worldData.ChunkHeightInVoxel) * worldData.ChunkHeightInVoxel,                z = Mathf.FloorToInt(voxelCoords.z / (float)worldData.ChunkSizeInVoxel) * worldData.ChunkSizeInVoxel            };        }        public static Vector3 GetChunkWorldPositionFromWorldCoords(World world, int worldX, int worldY, int worldZ) => GetChunkWorldPositionFromWorldCoords(world, new Vector3(worldX, worldY, worldZ));                public static Vector3 GetChunkWorldPositionFromWorldCoords(World world, Vector3 worldCoords)        {            return new Vector3            {                x = worldCoords.x / world.WorldData.ChunkSizeInWorld * world.WorldData.ChunkSizeInWorld,                y = worldCoords.y / world.WorldData.ChunkHeightInWorld * world.WorldData.ChunkHeightInWorld,                z = worldCoords.z / world.WorldData.ChunkSizeInWorld * world.WorldData.ChunkSizeInWorld            };        }        public static Vector3Int GetVoxelPositionFromWorldPosition(World world, Vector3 worldCoords)        {            return new Vector3Int            {                x = Mathf.RoundToInt(worldCoords.x / (float)world.WorldData.ChunkSizeInWorld * world.WorldData.ChunkSizeInVoxel),                y = Mathf.RoundToInt(worldCoords.y / (float)world.WorldData.ChunkHeightInWorld * world.WorldData.ChunkHeightInVoxel),                z = Mathf.RoundToInt(worldCoords.z / (float)world.WorldData.ChunkSizeInWorld * world.WorldData.ChunkSizeInVoxel)            };        }                public static Vector3 GetWorldPositionFromVoxelPosition(World world, Vector3Int voxelCoords)        {            return new Vector3            {                x = voxelCoords.x / (float)world.WorldData.ChunkSizeInVoxel * world.WorldData.ChunkSizeInWorld,                y = voxelCoords.y / (float)world.WorldData.ChunkHeightInVoxel * world.WorldData.ChunkHeightInWorld,                z = voxelCoords.z / (float)world.WorldData.ChunkSizeInVoxel * world.WorldData.ChunkSizeInWorld            };        }                public static Vector3 GetChunkWorldPositionFromVoxelCoords(World world, Vector3Int voxelCoords) => GetChunkWorldPositionFromVoxelCoords(world, voxelCoords.x, voxelCoords.y, voxelCoords.z);                public static Vector3 GetChunkWorldPositionFromVoxelCoords(World world, int voxelPositionX, int voxelPositionY, int voxelPositionZ)        {            var pos = new Vector3            {                x = voxelPositionX / (float)world.WorldData.ChunkSizeInVoxel * world.WorldData.ChunkSizeInWorld,                y = voxelPositionY / (float)world.WorldData.ChunkHeightInVoxel * world.WorldData.ChunkHeightInWorld,                z = voxelPositionZ / (float)world.WorldData.ChunkSizeInVoxel * world.WorldData.ChunkSizeInWorld            };            return pos;        }        public static void RemoveChunk(World world, Vector3Int voxelPos)        {            if (!world.WorldData.ChunkDictionary.TryGetValue(voxelPos, out var chunk)) return;            world.WorldRenderer.RemoveChunk(chunk);            world.WorldData.ChunkDictionary.TryRemove(voxelPos, out _);        }        public static void RemoveChunkData(World world, Vector3Int voxelPos)        {            if (!world.WorldData.ChunkDataDictionary.TryRemove(voxelPos, out var chunkData)) return;                        foreach (var chunkDecorationObject in chunkData.ChunkDecorations)            {                chunkDecorationObject.Dispose();            }            chunkData.ChunkDecorations.Clear();        }        public static void SetVoxel(World world, Vector3Int voxelCoords, VoxelType voxelType)        {            var chunkData = GetChunkDataFromVoxelCoords(world, voxelCoords);            if (chunkData == null) return;            var localPos = Chunk.GetChunkCoordinateOfVoxelPosition(chunkData, voxelCoords);            Chunk.SetVoxel(chunkData, localPos, voxelType);        }        public static ChunkData GetChunkDataFromVoxelCoords(World world, Vector3Int voxelCoords)         {            var chunkPos = GetChunkPositionFromVoxelCoords(world.WorldData, voxelCoords);            world.WorldData.ChunkDataDictionary.TryGetValue(chunkPos, out var containerChunk);            return containerChunk;        }        public static ChunkRenderer GetChunk(World worldReference, Vector3Int voxelPosition)        {            return worldReference.WorldData.ChunkDictionary.GetValueOrDefault(voxelPosition);        }        public static VoxelType GetVoxelTypeAt(World world, Vector3Int voxelPosition)        {            var chunkData = GetChunkDataFromVoxelCoords(world, voxelPosition);            return chunkData != null ?                Chunk.GetVoxelTypeAt(chunkData, Chunk.GetChunkCoordinateOfVoxelPosition(chunkData, voxelPosition)) :                world.terrainGenerator.ProcessVoxelAt(world, voxelPosition);        }        public static int GetSurfaceHeightAt(World world, Vector3Int voxelPosition)        {            var chunkData = GetChunkDataFromVoxelCoords(world, voxelPosition);            return chunkData != null ?                 Chunk.GetSurfaceHeight(chunkData, voxelPosition.XZ()) :                world.terrainGenerator.GetSurfaceHeightAt(world, voxelPosition);        }                public static VoxelType GetVoxelFromChunkCoordinates(ChunkData chunkData, int chunkPositionX, int chunkPositionY, int chunkPositionZ)        {            var worldData = chunkData.WorldReference.WorldData;            var voxelCoords = Chunk.GetVoxelCoordsFromChunkCoords(chunkData, chunkPositionX, chunkPositionY, chunkPositionZ);            var pos = GetChunkPositionFromVoxelCoords(worldData, voxelCoords);            worldData.ChunkDataDictionary.TryGetValue(pos, out var containerChunk);            if (containerChunk == null)                return VoxelType.Nothing;            var voxelChunkCoordinates = Chunk.GetChunkCoordinateOfVoxelPosition(containerChunk,                voxelCoords);            return Chunk.GetVoxelFromChunkCoordinates(containerChunk, voxelChunkCoordinates);        }        public static List<Vector3Int> GetAdjacentChunkPositionsInVoxel(World world, Vector3Int chunkPositionInVoxel)        {            var chunkSize = world.WorldData.ChunkSizeInVoxel;            List<Vector3Int> adjacentChunkPositions = new()            {                // "Below" -z                chunkPositionInVoxel + new Vector3Int(-chunkSize, 0, -chunkSize),                chunkPositionInVoxel + new Vector3Int(0, 0, -chunkSize),                chunkPositionInVoxel + new Vector3Int(chunkSize, 0, -chunkSize),                                //Center line (including the given position                chunkPositionInVoxel + new Vector3Int(-chunkSize, 0, 0),                chunkPositionInVoxel + new Vector3Int(chunkSize, 0, 0),                                // "Above" +z                chunkPositionInVoxel + new Vector3Int(-chunkSize, 0, chunkSize),                chunkPositionInVoxel + new Vector3Int(0, 0, chunkSize),                chunkPositionInVoxel + new Vector3Int(chunkSize, 0, chunkSize),            };            return adjacentChunkPositions;        }        public static BiomeType GetBiomeAt(World world, Vector3Int voxelPosition)        {            return world.terrainGenerator.GetBiomeAt(world, voxelPosition);        }    }}