using System.Collections.Generic;using System.Linq;using Unity.Mathematics.Geometry;using UnityEngine;using Voxel_Engine.WorldGen.Biomes;using Math = System.Math;namespace Voxel_Engine{    public static class WorldDataHelper    {        public static Vector3Int GetChunkPositionFromVoxelCoords(World world, Vector3Int voxelCoords)        {            return new Vector3Int            {                x = Mathf.FloorToInt(voxelCoords.x / (float)world.WorldData.ChunkSizeInVoxel) * world.WorldData.ChunkSizeInVoxel,                y = Mathf.FloorToInt(voxelCoords.y / (float)world.WorldData.ChunkHeightInVoxel) * world.WorldData.ChunkHeightInVoxel,                z = Mathf.FloorToInt(voxelCoords.z / (float)world.WorldData.ChunkSizeInVoxel) * world.WorldData.ChunkSizeInVoxel            };        }        public static Vector3 GetChunkWorldPositionFromWorldCoords(World world, int worldX, int worldY, int worldZ) => GetChunkWorldPositionFromWorldCoords(world, new Vector3(worldX, worldY, worldZ));                public static Vector3 GetChunkWorldPositionFromWorldCoords(World world, Vector3 worldCoords)        {            return new Vector3            {                x = worldCoords.x / world.WorldData.ChunkSizeInWorld * world.WorldData.ChunkSizeInWorld,                y = worldCoords.y / world.WorldData.ChunkHeightInWorld * world.WorldData.ChunkHeightInWorld,                z = worldCoords.z / world.WorldData.ChunkSizeInWorld * world.WorldData.ChunkSizeInWorld            };        }        public static Vector3Int GetVoxelPositionFromWorldPosition(World world, Vector3 worldCoords)        {            return new Vector3Int            {                x = Mathf.RoundToInt(worldCoords.x / (float)world.WorldData.ChunkSizeInWorld * world.WorldData.ChunkSizeInVoxel),                y = Mathf.RoundToInt(worldCoords.y / (float)world.WorldData.ChunkHeightInWorld * world.WorldData.ChunkHeightInVoxel),                z = Mathf.RoundToInt(worldCoords.z / (float)world.WorldData.ChunkSizeInWorld * world.WorldData.ChunkSizeInVoxel)            };        }                public static Vector3 GetWorldPositionFromVoxelPosition(World world, Vector3Int voxelCoords)        {            return new Vector3            {                x = voxelCoords.x / (float)world.WorldData.ChunkSizeInVoxel * world.WorldData.ChunkSizeInWorld,                y = voxelCoords.y / (float)world.WorldData.ChunkHeightInVoxel * world.WorldData.ChunkHeightInWorld,                z = voxelCoords.z / (float)world.WorldData.ChunkSizeInVoxel * world.WorldData.ChunkSizeInWorld            };        }                public static Vector3 GetChunkWorldPositionFromVoxelCoords(World world, Vector3Int voxelCoords) => GetChunkWorldPositionFromVoxelCoords(world, voxelCoords.x, voxelCoords.y, voxelCoords.z);                public static Vector3 GetChunkWorldPositionFromVoxelCoords(World world, int voxelPositionX, int voxelPositionY, int voxelPositionZ)        {            var pos = new Vector3            {                x = voxelPositionX / (float)world.WorldData.ChunkSizeInVoxel * world.WorldData.ChunkSizeInWorld,                y = voxelPositionY / (float)world.WorldData.ChunkHeightInVoxel * world.WorldData.ChunkHeightInWorld,                z = voxelPositionZ / (float)world.WorldData.ChunkSizeInVoxel * world.WorldData.ChunkSizeInWorld            };            return pos;        }                public static List<Vector3Int> GetChunkPositionsAroundPlayer(World world, Vector3Int playerVoxelPosition)        {            //TODO This whole thing is working with ints, even though the world coordinates are not ints...            // This needs to be changed to calculate the voxel positions instead.            //We calculate the chunk world position to avoid potential rounding errors in calculation            //var playerWorldPos = GetChunkWorldPositionFromWorldCoords(world, voxelPosition);            // var chunkWorldPos = GetChunkWorldPositionFromVoxelCoords(world, voxelPosition);            var chunkVoxelPos = GetChunkPositionFromVoxelCoords(world, playerVoxelPosition);            var startX = chunkVoxelPos.x - (world.ChunkDrawingRange) * world.WorldData.ChunkSizeInVoxel;            var startZ = chunkVoxelPos.z - (world.ChunkDrawingRange) * world.WorldData.ChunkSizeInVoxel;            var endX =   chunkVoxelPos.x + (world.ChunkDrawingRange) * world.WorldData.ChunkSizeInVoxel;             var endZ =   chunkVoxelPos.z + (world.ChunkDrawingRange) * world.WorldData.ChunkSizeInVoxel;            return GetPositionsAroundPlayer(world, startX, startZ, endX, endZ, playerVoxelPosition);        }        public static List<Vector3Int> GetDataPositionsAroundPlayer(World world, Vector3Int playerVoxelPosition)        {            //We calculate the chunk world position to avoid potential rounding errors in calculation            // var chunkWorldPos = GetChunkWorldPositionFromVoxelCoords(world, voxelPosition);            var chunkVoxelPos = GetChunkPositionFromVoxelCoords(world, playerVoxelPosition);            var startX = chunkVoxelPos.x - (world.ChunkDrawingRange + 1) * world.WorldData.ChunkSizeInVoxel;            var startZ = chunkVoxelPos.z - (world.ChunkDrawingRange + 1) * world.WorldData.ChunkSizeInVoxel;            var endX =   chunkVoxelPos.x   + (world.ChunkDrawingRange + 1) *   world.WorldData.ChunkSizeInVoxel;            var endZ =   chunkVoxelPos.z   + (world.ChunkDrawingRange + 1) *   world.WorldData.ChunkSizeInVoxel;            return GetPositionsAroundPlayer(world, startX, startZ, endX, endZ, playerVoxelPosition);        }        /// <summary>        /// Get Chunk positions around the player        /// </summary>        /// <param name="world"></param>        /// <param name="startX"></param>        /// <param name="startZ"></param>        /// <param name="endX"></param>        /// <param name="endZ"></param>        /// <param name="playerVoxelPosition"></param>        /// <returns></returns>        private static List<Vector3Int> GetPositionsAroundPlayer(World world, int startX, int startZ, int endX,            int endZ, Vector3Int playerVoxelPosition)        {            var positions = new List<Vector3Int>();            for (var x = startX; x <= endX; x += world.WorldData.ChunkSizeInVoxel)            {                for (var z = startZ; z <= endZ; z += world.WorldData.ChunkSizeInVoxel)                {                    var chunkVoxelPos = GetChunkPositionFromVoxelCoords(world, new Vector3Int(x, playerVoxelPosition.y, z));                    positions.Add(chunkVoxelPos);                                        if(    x < playerVoxelPosition.x - world.WorldData.ChunkSizeInVoxel                        || x > playerVoxelPosition.x + world.WorldData.ChunkSizeInVoxel                        || z < playerVoxelPosition.z - world.WorldData.ChunkSizeInVoxel                        || z > playerVoxelPosition.z + world.WorldData.ChunkSizeInVoxel) continue;                                        //Also add chunks below the current one, for digging down scenarios                    for (var y = -world.WorldData.ChunkHeightInVoxel; y >= playerVoxelPosition.y - world.WorldData.ChunkHeightInVoxel * 2; y -= world.WorldData.ChunkHeightInVoxel)                    {                        if (y == 0) continue;                        chunkVoxelPos = GetChunkPositionFromVoxelCoords(world, new Vector3Int(x, y, z));                        positions.Add(chunkVoxelPos);                    }                }            }            return positions;        }        public static List<Vector3Int> SelectPositionsToCreate(WorldData worldData, List<Vector3Int> allChunkPositionsNeeded, Vector3Int playerPositionInVoxel)        {            return allChunkPositionsNeeded                .Where(pos => worldData.ChunkDictionary.ContainsKey(pos) == false)                .OrderBy(pos => Vector3.Distance(playerPositionInVoxel, pos))                .ToList();        }        public static List<Vector3Int> SelectDataPositionsToCreate(WorldData worldData, List<Vector3Int> allChunkDataPositionsNeeded, Vector3Int playerPositionInVoxel)        {            return allChunkDataPositionsNeeded                .Where(pos => worldData.ChunkDataDictionary.ContainsKey(pos) == false)                .OrderBy(pos => Vector3.Distance(playerPositionInVoxel, pos))                .ToList();        }        public static List<Vector3Int> GetUnneededChunks(WorldData worldData, List<Vector3Int> allChunkPositionsNeeded)        {            return worldData.ChunkDictionary.Keys                .Where(pos => allChunkPositionsNeeded.Contains(pos) == false)                .ToList();        }        public static List<Vector3Int> GetUnneededData(WorldData worldData, List<Vector3Int> allChunkDataPositionsNeeded)        {            return worldData.ChunkDataDictionary.Keys                .Where(pos => allChunkDataPositionsNeeded.Contains(pos) == false                               && worldData.ChunkDataDictionary[pos].IsDirty() == false                              )                .ToList();        }        public static void RemoveChunk(World world, Vector3Int voxelPos)        {            if (!world.WorldData.ChunkDictionary.TryGetValue(voxelPos, out var chunk)) return;            world.WorldRenderer.RemoveChunk(chunk);            world.WorldData.ChunkDictionary.TryRemove(voxelPos, out _);        }        public static void RemoveChunkData(World world, Vector3Int voxelPos)        {            if (!world.WorldData.ChunkDataDictionary.TryRemove(voxelPos, out var chunkData)) return;                        foreach (var chunkDecorationObject in chunkData.ChunkDecorations)            {                chunkDecorationObject.Dispose();            }            chunkData.ChunkDecorations.Clear();        }        public static void SetVoxel(World world, Vector3Int voxelCoords, VoxelType voxelType)        {            var chunkData = GetChunkDataFromVoxelCoords(world, voxelCoords);            if (chunkData == null) return;            var localPos = Chunk.GetChunkCoordinateOfVoxelPosition(chunkData, voxelCoords);            Chunk.SetVoxel(chunkData, localPos, voxelType);        }        public static ChunkData GetChunkDataFromVoxelCoords(World world, Vector3Int voxelCoords)         {            var chunkPos = GetChunkPositionFromVoxelCoords(world, voxelCoords);            world.WorldData.ChunkDataDictionary.TryGetValue(chunkPos, out var containerChunk);            return containerChunk;        }        public static ChunkRenderer GetChunk(World worldReference, Vector3Int voxelPosition)        {            return worldReference.WorldData.ChunkDictionary.GetValueOrDefault(voxelPosition);        }        public static VoxelType GetVoxelTypeAt(World world, Vector3Int voxelPosition)        {            var chunkData = GetChunkDataFromVoxelCoords(world, voxelPosition);            return chunkData == null ?                world.terrainGenerator.ProcessVoxelAt(world, voxelPosition) :                Chunk.GetVoxelTypeAt(chunkData, Chunk.GetChunkCoordinateOfVoxelPosition(chunkData, voxelPosition));        }        public static int GetSurfaceHeightAt(World world, Vector3Int voxelPosition)        {            var chunkData = GetChunkDataFromVoxelCoords(world, voxelPosition);            return chunkData == null ?                 world.terrainGenerator.GetSurfaceHeightAt(world, voxelPosition) :                Chunk.GetSurfaceHeight(chunkData, voxelPosition.XZ());        }        public static List<Vector3Int> GetAdjacentChunkPositionsInVoxel(World world, Vector3Int chunkPositionInVoxel)        {            var chunkSize = world.WorldData.ChunkSizeInVoxel;            List<Vector3Int> adjacentChunkPositions = new()            {                // "Below" -z                chunkPositionInVoxel + new Vector3Int(-chunkSize, 0, -chunkSize),                chunkPositionInVoxel + new Vector3Int(0, 0, -chunkSize),                chunkPositionInVoxel + new Vector3Int(chunkSize, 0, -chunkSize),                                //Center line (including the given position                chunkPositionInVoxel + new Vector3Int(-chunkSize, 0, 0),                chunkPositionInVoxel + new Vector3Int(chunkSize, 0, 0),                                // "Above" +z                chunkPositionInVoxel + new Vector3Int(-chunkSize, 0, chunkSize),                chunkPositionInVoxel + new Vector3Int(0, 0, chunkSize),                chunkPositionInVoxel + new Vector3Int(chunkSize, 0, chunkSize),            };            return adjacentChunkPositions;        }        public static BiomeType GetBiomeAt(World world, Vector3Int voxelPosition)        {            return world.terrainGenerator.GetBiomeAt(world, voxelPosition);        }    }}